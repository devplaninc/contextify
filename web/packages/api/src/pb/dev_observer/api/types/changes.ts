// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.28.3
// source: dev_observer/api/types/changes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "dev_observer.api.types.changes";

export enum ChangeType {
  CHANGE_TYPE_UNSPECIFIED = 0,
  CHANGE_TYPE_ADDED = 1,
  CHANGE_TYPE_MODIFIED = 2,
  CHANGE_TYPE_DELETED = 3,
  CHANGE_TYPE_RENAMED = 4,
}

export function changeTypeFromJSON(object: any): ChangeType {
  switch (object) {
    case 0:
    case "CHANGE_TYPE_UNSPECIFIED":
      return ChangeType.CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "CHANGE_TYPE_ADDED":
      return ChangeType.CHANGE_TYPE_ADDED;
    case 2:
    case "CHANGE_TYPE_MODIFIED":
      return ChangeType.CHANGE_TYPE_MODIFIED;
    case 3:
    case "CHANGE_TYPE_DELETED":
      return ChangeType.CHANGE_TYPE_DELETED;
    case 4:
    case "CHANGE_TYPE_RENAMED":
      return ChangeType.CHANGE_TYPE_RENAMED;
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum ChangeType");
  }
}

export function changeTypeToJSON(object: ChangeType): string {
  switch (object) {
    case ChangeType.CHANGE_TYPE_UNSPECIFIED:
      return "CHANGE_TYPE_UNSPECIFIED";
    case ChangeType.CHANGE_TYPE_ADDED:
      return "CHANGE_TYPE_ADDED";
    case ChangeType.CHANGE_TYPE_MODIFIED:
      return "CHANGE_TYPE_MODIFIED";
    case ChangeType.CHANGE_TYPE_DELETED:
      return "CHANGE_TYPE_DELETED";
    case ChangeType.CHANGE_TYPE_RENAMED:
      return "CHANGE_TYPE_RENAMED";
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum ChangeType");
  }
}

export enum ChangesSummaryStatus {
  CHANGES_SUMMARY_STATUS_UNSPECIFIED = 0,
  CHANGES_SUMMARY_STATUS_PENDING = 1,
  CHANGES_SUMMARY_STATUS_PROCESSING = 2,
  CHANGES_SUMMARY_STATUS_COMPLETED = 3,
  CHANGES_SUMMARY_STATUS_FAILED = 4,
}

export function changesSummaryStatusFromJSON(object: any): ChangesSummaryStatus {
  switch (object) {
    case 0:
    case "CHANGES_SUMMARY_STATUS_UNSPECIFIED":
      return ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_UNSPECIFIED;
    case 1:
    case "CHANGES_SUMMARY_STATUS_PENDING":
      return ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_PENDING;
    case 2:
    case "CHANGES_SUMMARY_STATUS_PROCESSING":
      return ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_PROCESSING;
    case 3:
    case "CHANGES_SUMMARY_STATUS_COMPLETED":
      return ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_COMPLETED;
    case 4:
    case "CHANGES_SUMMARY_STATUS_FAILED":
      return ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_FAILED;
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum ChangesSummaryStatus");
  }
}

export function changesSummaryStatusToJSON(object: ChangesSummaryStatus): string {
  switch (object) {
    case ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_UNSPECIFIED:
      return "CHANGES_SUMMARY_STATUS_UNSPECIFIED";
    case ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_PENDING:
      return "CHANGES_SUMMARY_STATUS_PENDING";
    case ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_PROCESSING:
      return "CHANGES_SUMMARY_STATUS_PROCESSING";
    case ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_COMPLETED:
      return "CHANGES_SUMMARY_STATUS_COMPLETED";
    case ChangesSummaryStatus.CHANGES_SUMMARY_STATUS_FAILED:
      return "CHANGES_SUMMARY_STATUS_FAILED";
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum ChangesSummaryStatus");
  }
}

export interface GitHubChangesSummary {
  id: string;
  repoId: string;
  repoFullName: string;
  createdAt: Date | undefined;
  analysisPeriodStart: Date | undefined;
  analysisPeriodEnd: Date | undefined;
  content: ChangesSummaryContent | undefined;
  status: ChangesSummaryStatus;
  errorMessage?: string | undefined;
}

export interface ChangesSummaryContent {
  summary: string;
  commits: CommitInfo[];
  fileChanges: FileChange[];
  pullRequests: PullRequestInfo[];
  issues: IssueInfo[];
  statistics: ChangesStatistics | undefined;
}

export interface CommitInfo {
  sha: string;
  message: string;
  author: string;
  committedAt: Date | undefined;
  filesChanged: string[];
  additions: number;
  deletions: number;
}

export interface FileChange {
  filePath: string;
  changeType: ChangeType;
  additions: number;
  deletions: number;
  language?: string | undefined;
}

export interface PullRequestInfo {
  number: number;
  title: string;
  state: string;
  author: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  mergedAt: Date | undefined;
  labels: string[];
  additions: number;
  deletions: number;
}

export interface IssueInfo {
  number: number;
  title: string;
  state: string;
  author: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  closedAt: Date | undefined;
  labels: string[];
}

export interface ChangesStatistics {
  totalCommits: number;
  totalAdditions: number;
  totalDeletions: number;
  totalFilesChanged: number;
  totalPullRequests: number;
  totalIssues: number;
  languageStats: LanguageStats[];
}

export interface LanguageStats {
  language: string;
  filesChanged: number;
  additions: number;
  deletions: number;
}

function createBaseGitHubChangesSummary(): GitHubChangesSummary {
  return {
    id: "",
    repoId: "",
    repoFullName: "",
    createdAt: undefined,
    analysisPeriodStart: undefined,
    analysisPeriodEnd: undefined,
    content: undefined,
    status: 0,
    errorMessage: undefined,
  };
}

export const GitHubChangesSummary: MessageFns<GitHubChangesSummary> = {
  encode(message: GitHubChangesSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.repoId !== "") {
      writer.uint32(18).string(message.repoId);
    }
    if (message.repoFullName !== "") {
      writer.uint32(26).string(message.repoFullName);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.analysisPeriodStart !== undefined) {
      Timestamp.encode(toTimestamp(message.analysisPeriodStart), writer.uint32(42).fork()).join();
    }
    if (message.analysisPeriodEnd !== undefined) {
      Timestamp.encode(toTimestamp(message.analysisPeriodEnd), writer.uint32(50).fork()).join();
    }
    if (message.content !== undefined) {
      ChangesSummaryContent.encode(message.content, writer.uint32(58).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitHubChangesSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitHubChangesSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.repoId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repoFullName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.analysisPeriodStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.analysisPeriodEnd = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.content = ChangesSummaryContent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitHubChangesSummary {
    return {
      id: isSet(object.id) ? gt.String(object.id) : "",
      repoId: isSet(object.repoId) ? gt.String(object.repoId) : "",
      repoFullName: isSet(object.repoFullName) ? gt.String(object.repoFullName) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      analysisPeriodStart: isSet(object.analysisPeriodStart)
        ? fromJsonTimestamp(object.analysisPeriodStart)
        : undefined,
      analysisPeriodEnd: isSet(object.analysisPeriodEnd) ? fromJsonTimestamp(object.analysisPeriodEnd) : undefined,
      content: isSet(object.content) ? ChangesSummaryContent.fromJSON(object.content) : undefined,
      status: isSet(object.status) ? changesSummaryStatusFromJSON(object.status) : 0,
      errorMessage: isSet(object.errorMessage) ? gt.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: GitHubChangesSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.repoId !== "") {
      obj.repoId = message.repoId;
    }
    if (message.repoFullName !== "") {
      obj.repoFullName = message.repoFullName;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.analysisPeriodStart !== undefined) {
      obj.analysisPeriodStart = message.analysisPeriodStart.toISOString();
    }
    if (message.analysisPeriodEnd !== undefined) {
      obj.analysisPeriodEnd = message.analysisPeriodEnd.toISOString();
    }
    if (message.content !== undefined) {
      obj.content = ChangesSummaryContent.toJSON(message.content);
    }
    if (message.status !== 0) {
      obj.status = changesSummaryStatusToJSON(message.status);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<GitHubChangesSummary>): GitHubChangesSummary {
    return GitHubChangesSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitHubChangesSummary>): GitHubChangesSummary {
    const message = createBaseGitHubChangesSummary();
    message.id = object.id ?? "";
    message.repoId = object.repoId ?? "";
    message.repoFullName = object.repoFullName ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.analysisPeriodStart = object.analysisPeriodStart ?? undefined;
    message.analysisPeriodEnd = object.analysisPeriodEnd ?? undefined;
    message.content = (object.content !== undefined && object.content !== null)
      ? ChangesSummaryContent.fromPartial(object.content)
      : undefined;
    message.status = object.status ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseChangesSummaryContent(): ChangesSummaryContent {
  return { summary: "", commits: [], fileChanges: [], pullRequests: [], issues: [], statistics: undefined };
}

export const ChangesSummaryContent: MessageFns<ChangesSummaryContent> = {
  encode(message: ChangesSummaryContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== "") {
      writer.uint32(10).string(message.summary);
    }
    for (const v of message.commits) {
      CommitInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.fileChanges) {
      FileChange.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.pullRequests) {
      PullRequestInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.issues) {
      IssueInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.statistics !== undefined) {
      ChangesStatistics.encode(message.statistics, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangesSummaryContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangesSummaryContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commits.push(CommitInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileChanges.push(FileChange.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pullRequests.push(PullRequestInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.issues.push(IssueInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.statistics = ChangesStatistics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangesSummaryContent {
    return {
      summary: isSet(object.summary) ? gt.String(object.summary) : "",
      commits: gt.Array.isArray(object?.commits) ? object.commits.map((e: any) => CommitInfo.fromJSON(e)) : [],
      fileChanges: gt.Array.isArray(object?.fileChanges)
        ? object.fileChanges.map((e: any) => FileChange.fromJSON(e))
        : [],
      pullRequests: gt.Array.isArray(object?.pullRequests)
        ? object.pullRequests.map((e: any) => PullRequestInfo.fromJSON(e))
        : [],
      issues: gt.Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueInfo.fromJSON(e)) : [],
      statistics: isSet(object.statistics) ? ChangesStatistics.fromJSON(object.statistics) : undefined,
    };
  },

  toJSON(message: ChangesSummaryContent): unknown {
    const obj: any = {};
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.commits?.length) {
      obj.commits = message.commits.map((e) => CommitInfo.toJSON(e));
    }
    if (message.fileChanges?.length) {
      obj.fileChanges = message.fileChanges.map((e) => FileChange.toJSON(e));
    }
    if (message.pullRequests?.length) {
      obj.pullRequests = message.pullRequests.map((e) => PullRequestInfo.toJSON(e));
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => IssueInfo.toJSON(e));
    }
    if (message.statistics !== undefined) {
      obj.statistics = ChangesStatistics.toJSON(message.statistics);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangesSummaryContent>): ChangesSummaryContent {
    return ChangesSummaryContent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangesSummaryContent>): ChangesSummaryContent {
    const message = createBaseChangesSummaryContent();
    message.summary = object.summary ?? "";
    message.commits = object.commits?.map((e) => CommitInfo.fromPartial(e)) || [];
    message.fileChanges = object.fileChanges?.map((e) => FileChange.fromPartial(e)) || [];
    message.pullRequests = object.pullRequests?.map((e) => PullRequestInfo.fromPartial(e)) || [];
    message.issues = object.issues?.map((e) => IssueInfo.fromPartial(e)) || [];
    message.statistics = (object.statistics !== undefined && object.statistics !== null)
      ? ChangesStatistics.fromPartial(object.statistics)
      : undefined;
    return message;
  },
};

function createBaseCommitInfo(): CommitInfo {
  return { sha: "", message: "", author: "", committedAt: undefined, filesChanged: [], additions: 0, deletions: 0 };
}

export const CommitInfo: MessageFns<CommitInfo> = {
  encode(message: CommitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sha !== "") {
      writer.uint32(10).string(message.sha);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.author !== "") {
      writer.uint32(26).string(message.author);
    }
    if (message.committedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.committedAt), writer.uint32(34).fork()).join();
    }
    for (const v of message.filesChanged) {
      writer.uint32(42).string(v!);
    }
    if (message.additions !== 0) {
      writer.uint32(48).int32(message.additions);
    }
    if (message.deletions !== 0) {
      writer.uint32(56).int32(message.deletions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sha = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.committedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filesChanged.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.additions = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deletions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitInfo {
    return {
      sha: isSet(object.sha) ? gt.String(object.sha) : "",
      message: isSet(object.message) ? gt.String(object.message) : "",
      author: isSet(object.author) ? gt.String(object.author) : "",
      committedAt: isSet(object.committedAt) ? fromJsonTimestamp(object.committedAt) : undefined,
      filesChanged: gt.Array.isArray(object?.filesChanged) ? object.filesChanged.map((e: any) => gt.String(e)) : [],
      additions: isSet(object.additions) ? gt.Number(object.additions) : 0,
      deletions: isSet(object.deletions) ? gt.Number(object.deletions) : 0,
    };
  },

  toJSON(message: CommitInfo): unknown {
    const obj: any = {};
    if (message.sha !== "") {
      obj.sha = message.sha;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.committedAt !== undefined) {
      obj.committedAt = message.committedAt.toISOString();
    }
    if (message.filesChanged?.length) {
      obj.filesChanged = message.filesChanged;
    }
    if (message.additions !== 0) {
      obj.additions = Math.round(message.additions);
    }
    if (message.deletions !== 0) {
      obj.deletions = Math.round(message.deletions);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitInfo>): CommitInfo {
    return CommitInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitInfo>): CommitInfo {
    const message = createBaseCommitInfo();
    message.sha = object.sha ?? "";
    message.message = object.message ?? "";
    message.author = object.author ?? "";
    message.committedAt = object.committedAt ?? undefined;
    message.filesChanged = object.filesChanged?.map((e) => e) || [];
    message.additions = object.additions ?? 0;
    message.deletions = object.deletions ?? 0;
    return message;
  },
};

function createBaseFileChange(): FileChange {
  return { filePath: "", changeType: 0, additions: 0, deletions: 0, language: undefined };
}

export const FileChange: MessageFns<FileChange> = {
  encode(message: FileChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.additions !== 0) {
      writer.uint32(24).int32(message.additions);
    }
    if (message.deletions !== 0) {
      writer.uint32(32).int32(message.deletions);
    }
    if (message.language !== undefined) {
      writer.uint32(42).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.additions = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deletions = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileChange {
    return {
      filePath: isSet(object.filePath) ? gt.String(object.filePath) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      additions: isSet(object.additions) ? gt.Number(object.additions) : 0,
      deletions: isSet(object.deletions) ? gt.Number(object.deletions) : 0,
      language: isSet(object.language) ? gt.String(object.language) : undefined,
    };
  },

  toJSON(message: FileChange): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.additions !== 0) {
      obj.additions = Math.round(message.additions);
    }
    if (message.deletions !== 0) {
      obj.deletions = Math.round(message.deletions);
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    return obj;
  },

  create(base?: DeepPartial<FileChange>): FileChange {
    return FileChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileChange>): FileChange {
    const message = createBaseFileChange();
    message.filePath = object.filePath ?? "";
    message.changeType = object.changeType ?? 0;
    message.additions = object.additions ?? 0;
    message.deletions = object.deletions ?? 0;
    message.language = object.language ?? undefined;
    return message;
  },
};

function createBasePullRequestInfo(): PullRequestInfo {
  return {
    number: 0,
    title: "",
    state: "",
    author: "",
    createdAt: undefined,
    updatedAt: undefined,
    mergedAt: undefined,
    labels: [],
    additions: 0,
    deletions: 0,
  };
}

export const PullRequestInfo: MessageFns<PullRequestInfo> = {
  encode(message: PullRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(8).int32(message.number);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.state !== "") {
      writer.uint32(26).string(message.state);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (message.mergedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mergedAt), writer.uint32(58).fork()).join();
    }
    for (const v of message.labels) {
      writer.uint32(66).string(v!);
    }
    if (message.additions !== 0) {
      writer.uint32(72).int32(message.additions);
    }
    if (message.deletions !== 0) {
      writer.uint32(80).int32(message.deletions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mergedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.additions = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.deletions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullRequestInfo {
    return {
      number: isSet(object.number) ? gt.Number(object.number) : 0,
      title: isSet(object.title) ? gt.String(object.title) : "",
      state: isSet(object.state) ? gt.String(object.state) : "",
      author: isSet(object.author) ? gt.String(object.author) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      mergedAt: isSet(object.mergedAt) ? fromJsonTimestamp(object.mergedAt) : undefined,
      labels: gt.Array.isArray(object?.labels) ? object.labels.map((e: any) => gt.String(e)) : [],
      additions: isSet(object.additions) ? gt.Number(object.additions) : 0,
      deletions: isSet(object.deletions) ? gt.Number(object.deletions) : 0,
    };
  },

  toJSON(message: PullRequestInfo): unknown {
    const obj: any = {};
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.mergedAt !== undefined) {
      obj.mergedAt = message.mergedAt.toISOString();
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.additions !== 0) {
      obj.additions = Math.round(message.additions);
    }
    if (message.deletions !== 0) {
      obj.deletions = Math.round(message.deletions);
    }
    return obj;
  },

  create(base?: DeepPartial<PullRequestInfo>): PullRequestInfo {
    return PullRequestInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullRequestInfo>): PullRequestInfo {
    const message = createBasePullRequestInfo();
    message.number = object.number ?? 0;
    message.title = object.title ?? "";
    message.state = object.state ?? "";
    message.author = object.author ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.mergedAt = object.mergedAt ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    message.additions = object.additions ?? 0;
    message.deletions = object.deletions ?? 0;
    return message;
  },
};

function createBaseIssueInfo(): IssueInfo {
  return {
    number: 0,
    title: "",
    state: "",
    author: "",
    createdAt: undefined,
    updatedAt: undefined,
    closedAt: undefined,
    labels: [],
  };
}

export const IssueInfo: MessageFns<IssueInfo> = {
  encode(message: IssueInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(8).int32(message.number);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.state !== "") {
      writer.uint32(26).string(message.state);
    }
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (message.closedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.closedAt), writer.uint32(58).fork()).join();
    }
    for (const v of message.labels) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.closedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueInfo {
    return {
      number: isSet(object.number) ? gt.Number(object.number) : 0,
      title: isSet(object.title) ? gt.String(object.title) : "",
      state: isSet(object.state) ? gt.String(object.state) : "",
      author: isSet(object.author) ? gt.String(object.author) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      closedAt: isSet(object.closedAt) ? fromJsonTimestamp(object.closedAt) : undefined,
      labels: gt.Array.isArray(object?.labels) ? object.labels.map((e: any) => gt.String(e)) : [],
    };
  },

  toJSON(message: IssueInfo): unknown {
    const obj: any = {};
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.closedAt !== undefined) {
      obj.closedAt = message.closedAt.toISOString();
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    return obj;
  },

  create(base?: DeepPartial<IssueInfo>): IssueInfo {
    return IssueInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueInfo>): IssueInfo {
    const message = createBaseIssueInfo();
    message.number = object.number ?? 0;
    message.title = object.title ?? "";
    message.state = object.state ?? "";
    message.author = object.author ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.closedAt = object.closedAt ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBaseChangesStatistics(): ChangesStatistics {
  return {
    totalCommits: 0,
    totalAdditions: 0,
    totalDeletions: 0,
    totalFilesChanged: 0,
    totalPullRequests: 0,
    totalIssues: 0,
    languageStats: [],
  };
}

export const ChangesStatistics: MessageFns<ChangesStatistics> = {
  encode(message: ChangesStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCommits !== 0) {
      writer.uint32(8).int32(message.totalCommits);
    }
    if (message.totalAdditions !== 0) {
      writer.uint32(16).int32(message.totalAdditions);
    }
    if (message.totalDeletions !== 0) {
      writer.uint32(24).int32(message.totalDeletions);
    }
    if (message.totalFilesChanged !== 0) {
      writer.uint32(32).int32(message.totalFilesChanged);
    }
    if (message.totalPullRequests !== 0) {
      writer.uint32(40).int32(message.totalPullRequests);
    }
    if (message.totalIssues !== 0) {
      writer.uint32(48).int32(message.totalIssues);
    }
    for (const v of message.languageStats) {
      LanguageStats.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangesStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangesStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCommits = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalAdditions = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalDeletions = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalFilesChanged = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalPullRequests = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalIssues = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.languageStats.push(LanguageStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangesStatistics {
    return {
      totalCommits: isSet(object.totalCommits) ? gt.Number(object.totalCommits) : 0,
      totalAdditions: isSet(object.totalAdditions) ? gt.Number(object.totalAdditions) : 0,
      totalDeletions: isSet(object.totalDeletions) ? gt.Number(object.totalDeletions) : 0,
      totalFilesChanged: isSet(object.totalFilesChanged) ? gt.Number(object.totalFilesChanged) : 0,
      totalPullRequests: isSet(object.totalPullRequests) ? gt.Number(object.totalPullRequests) : 0,
      totalIssues: isSet(object.totalIssues) ? gt.Number(object.totalIssues) : 0,
      languageStats: gt.Array.isArray(object?.languageStats)
        ? object.languageStats.map((e: any) => LanguageStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangesStatistics): unknown {
    const obj: any = {};
    if (message.totalCommits !== 0) {
      obj.totalCommits = Math.round(message.totalCommits);
    }
    if (message.totalAdditions !== 0) {
      obj.totalAdditions = Math.round(message.totalAdditions);
    }
    if (message.totalDeletions !== 0) {
      obj.totalDeletions = Math.round(message.totalDeletions);
    }
    if (message.totalFilesChanged !== 0) {
      obj.totalFilesChanged = Math.round(message.totalFilesChanged);
    }
    if (message.totalPullRequests !== 0) {
      obj.totalPullRequests = Math.round(message.totalPullRequests);
    }
    if (message.totalIssues !== 0) {
      obj.totalIssues = Math.round(message.totalIssues);
    }
    if (message.languageStats?.length) {
      obj.languageStats = message.languageStats.map((e) => LanguageStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangesStatistics>): ChangesStatistics {
    return ChangesStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangesStatistics>): ChangesStatistics {
    const message = createBaseChangesStatistics();
    message.totalCommits = object.totalCommits ?? 0;
    message.totalAdditions = object.totalAdditions ?? 0;
    message.totalDeletions = object.totalDeletions ?? 0;
    message.totalFilesChanged = object.totalFilesChanged ?? 0;
    message.totalPullRequests = object.totalPullRequests ?? 0;
    message.totalIssues = object.totalIssues ?? 0;
    message.languageStats = object.languageStats?.map((e) => LanguageStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLanguageStats(): LanguageStats {
  return { language: "", filesChanged: 0, additions: 0, deletions: 0 };
}

export const LanguageStats: MessageFns<LanguageStats> = {
  encode(message: LanguageStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.filesChanged !== 0) {
      writer.uint32(16).int32(message.filesChanged);
    }
    if (message.additions !== 0) {
      writer.uint32(24).int32(message.additions);
    }
    if (message.deletions !== 0) {
      writer.uint32(32).int32(message.deletions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filesChanged = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.additions = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deletions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageStats {
    return {
      language: isSet(object.language) ? gt.String(object.language) : "",
      filesChanged: isSet(object.filesChanged) ? gt.Number(object.filesChanged) : 0,
      additions: isSet(object.additions) ? gt.Number(object.additions) : 0,
      deletions: isSet(object.deletions) ? gt.Number(object.deletions) : 0,
    };
  },

  toJSON(message: LanguageStats): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.filesChanged !== 0) {
      obj.filesChanged = Math.round(message.filesChanged);
    }
    if (message.additions !== 0) {
      obj.additions = Math.round(message.additions);
    }
    if (message.deletions !== 0) {
      obj.deletions = Math.round(message.deletions);
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageStats>): LanguageStats {
    return LanguageStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageStats>): LanguageStats {
    const message = createBaseLanguageStats();
    message.language = object.language ?? "";
    message.filesChanged = object.filesChanged ?? 0;
    message.additions = object.additions ?? 0;
    message.deletions = object.deletions ?? 0;
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new gt.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof gt.Date) {
    return o;
  } else if (typeof o === "string") {
    return new gt.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
