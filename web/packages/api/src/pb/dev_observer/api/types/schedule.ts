// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.28.3
// source: dev_observer/api/types/schedule.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "dev_observer.api.types.schedule";

export enum DayOfWeek {
  DAY_OF_WEEK_UNSPECIFIED = 0,
  MONDAY = 1,
  TUESDAY = 2,
  WEDNESDAY = 3,
  THURSDAY = 4,
  FRIDAY = 5,
  SATURDAY = 6,
  SUNDAY = 7,
}

export function dayOfWeekFromJSON(object: any): DayOfWeek {
  switch (object) {
    case 0:
    case "DAY_OF_WEEK_UNSPECIFIED":
      return DayOfWeek.DAY_OF_WEEK_UNSPECIFIED;
    case 1:
    case "MONDAY":
      return DayOfWeek.MONDAY;
    case 2:
    case "TUESDAY":
      return DayOfWeek.TUESDAY;
    case 3:
    case "WEDNESDAY":
      return DayOfWeek.WEDNESDAY;
    case 4:
    case "THURSDAY":
      return DayOfWeek.THURSDAY;
    case 5:
    case "FRIDAY":
      return DayOfWeek.FRIDAY;
    case 6:
    case "SATURDAY":
      return DayOfWeek.SATURDAY;
    case 7:
    case "SUNDAY":
      return DayOfWeek.SUNDAY;
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum DayOfWeek");
  }
}

export function dayOfWeekToJSON(object: DayOfWeek): string {
  switch (object) {
    case DayOfWeek.DAY_OF_WEEK_UNSPECIFIED:
      return "DAY_OF_WEEK_UNSPECIFIED";
    case DayOfWeek.MONDAY:
      return "MONDAY";
    case DayOfWeek.TUESDAY:
      return "TUESDAY";
    case DayOfWeek.WEDNESDAY:
      return "WEDNESDAY";
    case DayOfWeek.THURSDAY:
      return "THURSDAY";
    case DayOfWeek.FRIDAY:
      return "FRIDAY";
    case DayOfWeek.SATURDAY:
      return "SATURDAY";
    case DayOfWeek.SUNDAY:
      return "SUNDAY";
    default:
      throw new gt.Error("Unrecognized enum value " + object + " for enum DayOfWeek");
  }
}

export interface Schedule {
  frequency: Frequency | undefined;
}

export interface Frequency {
  type?: { $case: "daily"; value: Frequency_Daily } | { $case: "weekly"; value: Frequency_Weekly } | undefined;
}

export interface Frequency_Daily {
  time: Time | undefined;
}

export interface Frequency_Weekly {
  dayOfWeek: DayOfWeek;
  time: Time | undefined;
}

export interface TimeOfDay {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
   * to allow the value "24:00:00" for scenarios like business closing time.
   */
  hours: number;
  /** Minutes of hour of day. Must be from 0 to 59. */
  minutes: number;
  /**
   * Seconds of minute of hour. Must be from 0 to 60. This accounts for leap
   * seconds in certain timezones. The value 60 is only valid for leap seconds.
   */
  seconds: number;
  /** Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999. */
  nanos: number;
}

export interface Time {
  timeOfDay: TimeOfDay | undefined;
  timeZone: TimeZone | undefined;
}

/**
 * Represents a time zone from the
 * [IANA Time Zone Database](https://www.iana.org/time-zones).
 */
export interface TimeZone {
  /** IANA Time Zone Database time zone, e.g. "America/New_York". */
  id: string;
}

function createBaseSchedule(): Schedule {
  return { frequency: undefined };
}

export const Schedule: MessageFns<Schedule> = {
  encode(message: Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frequency !== undefined) {
      Frequency.encode(message.frequency, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.frequency = Frequency.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schedule {
    return { frequency: isSet(object.frequency) ? Frequency.fromJSON(object.frequency) : undefined };
  },

  toJSON(message: Schedule): unknown {
    const obj: any = {};
    if (message.frequency !== undefined) {
      obj.frequency = Frequency.toJSON(message.frequency);
    }
    return obj;
  },

  create(base?: DeepPartial<Schedule>): Schedule {
    return Schedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schedule>): Schedule {
    const message = createBaseSchedule();
    message.frequency = (object.frequency !== undefined && object.frequency !== null)
      ? Frequency.fromPartial(object.frequency)
      : undefined;
    return message;
  },
};

function createBaseFrequency(): Frequency {
  return { type: undefined };
}

export const Frequency: MessageFns<Frequency> = {
  encode(message: Frequency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.type?.$case) {
      case "daily":
        Frequency_Daily.encode(message.type.value, writer.uint32(802).fork()).join();
        break;
      case "weekly":
        Frequency_Weekly.encode(message.type.value, writer.uint32(810).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frequency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrequency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.type = { $case: "daily", value: Frequency_Daily.decode(reader, reader.uint32()) };
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.type = { $case: "weekly", value: Frequency_Weekly.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frequency {
    return {
      type: isSet(object.daily)
        ? { $case: "daily", value: Frequency_Daily.fromJSON(object.daily) }
        : isSet(object.weekly)
        ? { $case: "weekly", value: Frequency_Weekly.fromJSON(object.weekly) }
        : undefined,
    };
  },

  toJSON(message: Frequency): unknown {
    const obj: any = {};
    if (message.type?.$case === "daily") {
      obj.daily = Frequency_Daily.toJSON(message.type.value);
    } else if (message.type?.$case === "weekly") {
      obj.weekly = Frequency_Weekly.toJSON(message.type.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Frequency>): Frequency {
    return Frequency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Frequency>): Frequency {
    const message = createBaseFrequency();
    switch (object.type?.$case) {
      case "daily": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "daily", value: Frequency_Daily.fromPartial(object.type.value) };
        }
        break;
      }
      case "weekly": {
        if (object.type?.value !== undefined && object.type?.value !== null) {
          message.type = { $case: "weekly", value: Frequency_Weekly.fromPartial(object.type.value) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseFrequency_Daily(): Frequency_Daily {
  return { time: undefined };
}

export const Frequency_Daily: MessageFns<Frequency_Daily> = {
  encode(message: Frequency_Daily, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Time.encode(message.time, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frequency_Daily {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrequency_Daily();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = Time.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frequency_Daily {
    return { time: isSet(object.time) ? Time.fromJSON(object.time) : undefined };
  },

  toJSON(message: Frequency_Daily): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = Time.toJSON(message.time);
    }
    return obj;
  },

  create(base?: DeepPartial<Frequency_Daily>): Frequency_Daily {
    return Frequency_Daily.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Frequency_Daily>): Frequency_Daily {
    const message = createBaseFrequency_Daily();
    message.time = (object.time !== undefined && object.time !== null) ? Time.fromPartial(object.time) : undefined;
    return message;
  },
};

function createBaseFrequency_Weekly(): Frequency_Weekly {
  return { dayOfWeek: 0, time: undefined };
}

export const Frequency_Weekly: MessageFns<Frequency_Weekly> = {
  encode(message: Frequency_Weekly, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dayOfWeek !== 0) {
      writer.uint32(8).int32(message.dayOfWeek);
    }
    if (message.time !== undefined) {
      Time.encode(message.time, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frequency_Weekly {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrequency_Weekly();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.time = Time.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frequency_Weekly {
    return {
      dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekFromJSON(object.dayOfWeek) : 0,
      time: isSet(object.time) ? Time.fromJSON(object.time) : undefined,
    };
  },

  toJSON(message: Frequency_Weekly): unknown {
    const obj: any = {};
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekToJSON(message.dayOfWeek);
    }
    if (message.time !== undefined) {
      obj.time = Time.toJSON(message.time);
    }
    return obj;
  },

  create(base?: DeepPartial<Frequency_Weekly>): Frequency_Weekly {
    return Frequency_Weekly.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Frequency_Weekly>): Frequency_Weekly {
    const message = createBaseFrequency_Weekly();
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.time = (object.time !== undefined && object.time !== null) ? Time.fromPartial(object.time) : undefined;
    return message;
  },
};

function createBaseTimeOfDay(): TimeOfDay {
  return { hours: 0, minutes: 0, seconds: 0, nanos: 0 };
}

export const TimeOfDay: MessageFns<TimeOfDay> = {
  encode(message: TimeOfDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hours !== 0) {
      writer.uint32(8).int32(message.hours);
    }
    if (message.minutes !== 0) {
      writer.uint32(16).int32(message.minutes);
    }
    if (message.seconds !== 0) {
      writer.uint32(24).int32(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(32).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeOfDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeOfDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hours = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minutes = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.seconds = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeOfDay {
    return {
      hours: isSet(object.hours) ? gt.Number(object.hours) : 0,
      minutes: isSet(object.minutes) ? gt.Number(object.minutes) : 0,
      seconds: isSet(object.seconds) ? gt.Number(object.seconds) : 0,
      nanos: isSet(object.nanos) ? gt.Number(object.nanos) : 0,
    };
  },

  toJSON(message: TimeOfDay): unknown {
    const obj: any = {};
    if (message.hours !== 0) {
      obj.hours = Math.round(message.hours);
    }
    if (message.minutes !== 0) {
      obj.minutes = Math.round(message.minutes);
    }
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create(base?: DeepPartial<TimeOfDay>): TimeOfDay {
    return TimeOfDay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeOfDay>): TimeOfDay {
    const message = createBaseTimeOfDay();
    message.hours = object.hours ?? 0;
    message.minutes = object.minutes ?? 0;
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseTime(): Time {
  return { timeOfDay: undefined, timeZone: undefined };
}

export const Time: MessageFns<Time> = {
  encode(message: Time, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeOfDay !== undefined) {
      TimeOfDay.encode(message.timeOfDay, writer.uint32(10).fork()).join();
    }
    if (message.timeZone !== undefined) {
      TimeZone.encode(message.timeZone, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Time {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeOfDay = TimeOfDay.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Time {
    return {
      timeOfDay: isSet(object.timeOfDay) ? TimeOfDay.fromJSON(object.timeOfDay) : undefined,
      timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
    };
  },

  toJSON(message: Time): unknown {
    const obj: any = {};
    if (message.timeOfDay !== undefined) {
      obj.timeOfDay = TimeOfDay.toJSON(message.timeOfDay);
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    return obj;
  },

  create(base?: DeepPartial<Time>): Time {
    return Time.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Time>): Time {
    const message = createBaseTime();
    message.timeOfDay = (object.timeOfDay !== undefined && object.timeOfDay !== null)
      ? TimeOfDay.fromPartial(object.timeOfDay)
      : undefined;
    message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
      ? TimeZone.fromPartial(object.timeZone)
      : undefined;
    return message;
  },
};

function createBaseTimeZone(): TimeZone {
  return { id: "" };
}

export const TimeZone: MessageFns<TimeZone> = {
  encode(message: TimeZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeZone {
    return { id: isSet(object.id) ? gt.String(object.id) : "" };
  },

  toJSON(message: TimeZone): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeZone>): TimeZone {
    return TimeZone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeZone>): TimeZone {
    const message = createBaseTimeZone();
    message.id = object.id ?? "";
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
